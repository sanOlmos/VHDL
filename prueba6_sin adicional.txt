library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity bin_bcd is
    PORT(
        num_bin: in  STD_LOGIC_VECTOR(12 downto 0);
        seg:     out STD_LOGIC_VECTOR(6 downto 0);
        an:      out STD_LOGIC_VECTOR(3 downto 0);
        clk:     in  STD_LOGIC;
        conversion: in STD_LOGIC;
        freeze: in STD_LOGIC;
        test: in STD_LOGIC;
        reset: in STD_LOGIC
    );
end bin_bcd;

architecture Behavioral of bin_bcd is
    signal k0_bcd, k1_bcd, k2_bcd, k3_bcd: std_logic_vector(3 downto 0);
    signal count: integer range 0 to 3 := 0;
    signal seg_temp: STD_LOGIC_VECTOR(6 downto 0);
begin
    proceso_bcd: process(clk, conversion, reset)
        variable z: STD_LOGIC_VECTOR(27 downto 0);
    begin
        if rising_edge(clk) then
            if reset = '1' then
                -- Reset all data.
                z := (others => '0');
                k0_bcd <= (others => '0');
                k1_bcd <= (others => '0');
                k2_bcd <= (others => '0');
                k3_bcd <= (others => '0');
            elsif conversion = '0' and freeze = '0' then
                -- InicializaciÃ³n de datos en cero.
                z := (others => '0');
                -- Se realizan los primeros tres corrimientos.
                z(14 downto 2) := num_bin;
                for i in 0 to 8 loop
                    -- Unidades (4 bits).
                    if z(16 downto 13) > 4 then
                        z(16 downto 13) := z(16 downto 13) + 3;
                    end if;
                    -- Decenas (4 bits).
                    if z(20 downto 17) > 4 then
                        z(20 downto 17) := z(20 downto 17) + 3;
                    end if;
                    -- Centenas (4 bits).
                    if z(24 downto 21) > 4 then
                        z(24 downto 21) := z(24 downto 21) + 3;
                    end if;
                    -- Miles (4 bits).
                    if z(27 downto 24) > 4 then
                        z(27 downto 24) := z(27 downto 24) + 3;
                    end if;
                    -- Corrimiento a la izquierda.
                    z(27 downto 1) := z(26 downto 0);
                end loop;
                -- Pasando datos de variable Z, correspondiente a BCD.
                k0_bcd<=z(16 downto 13);
                k1_bcd<=z(20 downto 17);
                k2_bcd<=z(24 downto 21);
                k3_bcd<=z(27 downto 24);
            end if;
        end if;
    end process;

    process(clk)
    begin
        if rising_edge(clk) then
            count <= count +1;
            if count =4 then
                count <=0;
            end if;

            case count is
                when others =>
                    null; 
            end case;

            seg <= seg_temp;

            -- Test mode.
            if test = '1' then
                seg <= "0000111"; -- Display "8".
                an <= "0000"; -- All digits on.
            end if;

        end if;
    end process;

end Behavioral;